
#include <Servo.h>
#include <Wire.h>
#include <SPI.h>
#include <math.h>

// === PIN ASSIGNMENTS ===
const int PIN_SERVO_FRONT = 3;
const int PIN_SERVO_RIGHT = 5;
const int PIN_SERVO_BACK  = 9;
const int PIN_SERVO_LEFT  = 6;

const int PIN_JOYSTICK_PITCH = A4;  // vertical axis
const int PIN_JOYSTICK_YAW   = A5;  // horizontal axis

// === CONSTANTS ===
const float FIN_ANGLE_MAX   = 30.0f;   // degrees
const int   SERVO_CENTER    = 90;      // center PWM
const int   SERVO_RANGE     = 60;      // ±30° span

const float ACC_MAGNITUDE   = 2.0f;    // m/s² along body‐axis (always)
const float WAYPOINT_TOL    = 2.0f;    // meters tolerance for “reached”

// PD gains (tune if needed)
const float Kp_pitch = 2.0f;    // deg/s² per deg error
const float Kd_pitch = 0.8f;    // damping
const float Kp_yaw   = 2.0f;
const float Kd_yaw   = 0.8f;

// === GLOBAL VARIABLES ===
Servo finFront, finRight, finBack, finLeft;

String mode = "";            // "", "MAN", or "AUTO"
bool isLaunched     = false;
bool autoParamsSet  = false;
int  autoInputStage = 0;     // 0 = X, 1 = Y, 2 = Z, 3 = ready

unsigned long launchMillis     = 0;
unsigned long lastUpdateMillis = 0;
unsigned long lastPrintMillis  = 0;

float posX = 0, posY = 0, posZ = 0;   // m
float velX = 0, velY = 0, velZ = 0;   // m/s
float accX = 0, accY = 0, accZ = 0;   // m/s²

float pitchDeg = 0, yawDeg = 0, rollDeg = 0;    // deg
float pitchRate = 0, yawRate = 0, rollRate = 0; // deg/s

float waypointX = 0, waypointY = 0, waypointZ = 0;
float prevDist3D = 1e6f;   // track distance for closest‐approach logic

// === FUNCTION DECLARATIONS ===
void setup();
void loop();
void handleSerial();
void enterManualMode();
void enterAutoMode();
void manualModeLoop();
void autoModeLoop();
void updateRocketPhysics(float dt);
void computeAttitudeFromIMU(float dt);  // stub
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg);
float mapJoystickToAngle(int reading);

// === SETUP ===
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("=== Rocket Controller Starting ===");

  // Attach servos
  finFront.attach(PIN_SERVO_FRONT);
  finRight.attach(PIN_SERVO_RIGHT);
  finBack.attach(PIN_SERVO_BACK);
  finLeft.attach(PIN_SERVO_LEFT);

  // Center fins
  setAllFins(0, 0, 0, 0);

  lastUpdateMillis = millis();
  lastPrintMillis  = millis();
}

// === MAIN LOOP ===
void loop() {
  handleSerial();

  if (mode == "MAN") {
    manualModeLoop();
  }
  else if (mode == "AUTO") {
    autoModeLoop();
  }
  else {
    // Idle until “MAN” or “AUTO” is entered
  }
}

// === SERIAL HANDLING ===
void handleSerial() {
  if (!Serial.available()) return;

  String input = Serial.readStringUntil('\n');
  input.trim();

  // In MAN mode, “ABORT” stops motion and returns to idle
  if (mode == "MAN" && input.equalsIgnoreCase("ABORT")) {
    setAllFins(0, 0, 0, 0);
    Serial.println("Manual ABORT. Waiting for 'MAN' or 'AUTO'.");
    mode = "";
    isLaunched = false;
    return;
  }

  // Enter MANUAL
  if (input.equalsIgnoreCase("MAN")) {
    mode = "MAN";
    enterManualMode();
    return;
  }

  // Enter AUTO
  if (input.equalsIgnoreCase("AUTO")) {
    mode = "AUTO";
    enterAutoMode();
    return;
  }

  // In AUTO, parse waypoint X, Y, Z in sequence
  if (mode == "AUTO" && !autoParamsSet) {
    float val = input.toFloat();
    bool valid = false;
    if (autoInputStage == 0) {
      waypointX = val;
      valid = true;
    }
    else if (autoInputStage == 1) {
      waypointY = val;
      valid = true;
    }
    else if (autoInputStage == 2) {
      waypointZ = val;
      valid = true;
    }
    if (valid) {
      autoInputStage++;
      if (autoInputStage == 1) {
        Serial.print("Waypoint X = "); Serial.println(waypointX, 2);
        Serial.println("Enter waypoint Y:");
        Serial.print("> ");
      }
      else if (autoInputStage == 2) {
        Serial.print("Waypoint Y = "); Serial.println(waypointY, 2);
        Serial.println("Enter waypoint Z:");
        Serial.print("> ");
      }
      else if (autoInputStage == 3) {
        Serial.print("Waypoint Z = "); Serial.println(waypointZ, 2);
        autoParamsSet = true;
        Serial.println("Waypoint set. Starting AUTO...");
        // Initialize for AUTO
        isLaunched = false;  
        prevDist3D = 1e6f;
        posX = posY = posZ = 0;
        velX = velY = velZ = 0;
        pitchDeg = yawDeg = rollDeg = 0;
        pitchRate = yawRate = rollRate = 0;
      }
    }
    else {
      Serial.println("Invalid number. Please re-enter:");
      if (autoInputStage == 0) {
        Serial.println("Enter waypoint X:");
      } else if (autoInputStage == 1) {
        Serial.println("Enter waypoint Y:");
      } else if (autoInputStage == 2) {
        Serial.println("Enter waypoint Z:");
      }
      Serial.print("> ");
    }
  }
}

// === MODE SWITCH ROUTINES ===
void enterManualMode() {
  Serial.println("===== MANUAL MODE =====");
  Serial.println("Type 'ABORT' to exit manual mode.");
  mode = "MAN";
  autoParamsSet = false;
  autoInputStage = 0;
  isLaunched = false;
}

void enterAutoMode() {
  Serial.println("===== AUTO MODE =====");
  mode = "AUTO";
  autoParamsSet = false;
  autoInputStage = 0;
  Serial.println("Enter waypoint X:");
  Serial.print("> ");
}

// === MANUAL MODE ===
void manualModeLoop() {
  // 1) Read joystick (0–1023)
  int rawPitch = analogRead(PIN_JOYSTICK_PITCH);
  int rawYaw   = analogRead(PIN_JOYSTICK_YAW);

  // 2) Map to ±FIN_ANGLE_MAX
  float pitchDef = mapJoystickToAngle(rawPitch);
  float yawDef   = mapJoystickToAngle(rawYaw);

  // 3) Compute fins: front/back = pitch, right/left = yaw
  float finFrontDeg = pitchDef;
  float finBackDeg  = -pitchDef;
  float finRightDeg = yawDef;
  float finLeftDeg  = -yawDef;

  setAllFins(finFrontDeg, finRightDeg, finBackDeg, finLeftDeg);

  // 4) Update attitude stub (or IMU if available)
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3f;
  lastUpdateMillis = now;
  computeAttitudeFromIMU(dt);

  // 5) Even in MANUAL, we still “accelerate” 2 m/s² along body axis
  updateRocketPhysics(dt);

  // 6) Print (X,Y,Z) and attitude every 250 ms
  if (now - lastPrintMillis >= 250) {
    lastPrintMillis = now;
    Serial.print("MANUAL | POS(m)=(");
    Serial.print(posX,  2); Serial.print(",");
    Serial.print(posY,  2); Serial.print(",");
    Serial.print(posZ,  2); Serial.print(") ");
    Serial.print("ATT°=P:");
    Serial.print(pitchDeg, 1); Serial.print(" Y:");
    Serial.print(yawDeg,   1); Serial.print(" R:");
    Serial.println(rollDeg, 1);
  }

  delay(10);
}

// === AUTO MODE ===
void autoModeLoop() {
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3f;
  lastUpdateMillis = now;

  if (!autoParamsSet) {
    // Still waiting for user to enter X, Y, Z
    return;
  }

  // 1) Initialize on first AUTO call
  if (!isLaunched) {
    isLaunched = true;
    launchMillis = millis();
    posX = posY = posZ = 0;
    velX = velY = velZ = 0;
    pitchDeg = yawDeg = rollDeg = 0;
    pitchRate = yawRate = rollRate = 0;
    prevDist3D = 1e6f;
  }

  // 2) Compute 3D error to waypoint
  float dX = waypointX - posX;
  float dY = waypointY - posY;
  float dZ = waypointZ - posZ;
  float dist3D = sqrt(dX*dX + dY*dY + dZ*dZ);

  // 3) Track closest approach
  static bool passedClosest = false;
  if (dist3D < prevDist3D) {
    prevDist3D = dist3D;
    passedClosest = false;
  } else if (!passedClosest && dist3D > prevDist3D) {
    passedClosest = true;
  }

  // 4) If within tolerance or passed closest, stop
  if (dist3D <= WAYPOINT_TOL || passedClosest) {
    setAllFins(0, 0, 0, 0);
    Serial.print("Waypoint reached! Closest dist = ");
    Serial.print(prevDist3D, 2);
    Serial.print(" m at POS=(");
    Serial.print(posX,  2); Serial.print(",");
    Serial.print(posY,  2); Serial.print(",");
    Serial.print(posZ,  2); Serial.println(")");
    // Reset for next command
    mode = "";
    isLaunched = false;
    autoParamsSet = false;
    Serial.println("Enter 'MAN' or 'AUTO' to continue.");
    return;
  }

  // 5) Compute desired attitude toward waypoint
  float distXY = sqrt(dX*dX + dY*dY) + 1e-6f;
  float desiredPitch = atan2(dZ, distXY) * 180.0f / PI;
  float desiredYaw   = atan2(dY, dX)   * 180.0f / PI;

  float errPitch = desiredPitch - pitchDeg;
  float errYaw   = desiredYaw   - yawDeg;
  if (errYaw > 180.0f)  errYaw -= 360.0f;
  if (errYaw < -180.0f) errYaw += 360.0f;

  // 6) PD control for pitch
  float pitchErrorDerivative = -pitchRate;
  float pitchAcc = Kp_pitch * errPitch + Kd_pitch * pitchErrorDerivative;
  pitchRate += pitchAcc * dt;
  pitchDeg  += pitchRate * dt;

  // 7) PD control for yaw
  float yawErrorDerivative = -yawRate;
  float yawAcc = Kp_yaw * errYaw + Kd_yaw * yawErrorDerivative;
  yawRate += yawAcc * dt;
  yawDeg  += yawRate * dt;

  // 8) Compute residual errors
  float errPitch2 = desiredPitch - pitchDeg;
  float errYaw2   = desiredYaw   - yawDeg;
  if (errYaw2 > 180.0f)  errYaw2 -= 360.0f;
  if (errYaw2 < -180.0f) errYaw2 += 360.0f;

  // 9) Fin deflections from residuals
  float finPitchCmd = constrain(errPitch2 * 0.5f, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);
  float finYawCmd   = constrain(errYaw2   * 0.5f, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);

  float frontCmd = finPitchCmd;
  float backCmd  = -finPitchCmd;
  float rightCmd = finYawCmd;
  float leftCmd  = -finYawCmd;

  // 10) Smooth deflections
  static float filtFront = 0, filtBack = 0, filtRight = 0, filtLeft = 0;
  const float alpha = 0.02f;
  filtFront = filtFront + alpha * (frontCmd - filtFront);
  filtBack  = filtBack  + alpha * (backCmd  - filtBack);
  filtRight = filtRight + alpha * (rightCmd - filtRight);
  filtLeft  = filtLeft  + alpha * (leftCmd  - filtLeft);

  setAllFins(filtFront, filtRight, filtBack, filtLeft);

  // 11) Update physics with constant 2 m/s² along body axis
  updateRocketPhysics(dt);

  // 12) Print telemetry every 250 ms
  if (now - lastPrintMillis >= 250) {
    lastPrintMillis = now;
    Serial.print("AUTO | POS(m)=(");
    Serial.print(posX,  2); Serial.print(",");
    Serial.print(posY,  2); Serial.print(",");
    Serial.print(posZ,  2); Serial.print(") ");
    Serial.print("Dist="); Serial.print(dist3D, 2); Serial.print("m ");
    Serial.print("| Fins=(P:");
    Serial.print(filtFront, 1); Serial.print(",Y:");
    Serial.print(filtRight, 1); Serial.print(",");
    Serial.print(filtBack,  1); Serial.print(",");
    Serial.print(filtLeft,  1); Serial.println(")");
  }

  delay(10);
}

// === UPDATE ROCKET PHYSICS ===
void updateRocketPhysics(float dt) {
  // Always accelerate 2 m/s² along body axis (defined by pitchDeg, yawDeg)
  float pitchRad = pitchDeg * PI / 180.0f;
  float yawRad   = yawDeg   * PI / 180.0f;

  // Body‐axis unit vector (in inertial frame):
  float ux = sin(pitchRad) * cos(yawRad);
  float uy = sin(pitchRad) * sin(yawRad);
  float uz = cos(pitchRad);

  accX = ACC_MAGNITUDE * ux;
  accY = ACC_MAGNITUDE * uy;
  accZ = ACC_MAGNITUDE * uz;

  // Integrate velocity
  velX += accX * dt;
  velY += accY * dt;
  velZ += accZ * dt;

  // Integrate position
  posX += velX * dt;
  posY += velY * dt;
  posZ += velZ * dt;
}

// === STUB: ATTITUDE FROM IMU ===
void computeAttitudeFromIMU(float dt) {
  // If you have an IMU or MPU6050 + filter, insert the code here
  // to update pitchDeg, yawDeg, rollDeg, pitchRate, yawRate, rollRate.
  // Otherwise, attitude is driven by our PD loop in autoModeLoop().
}

// === SET ALL FINS ===
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg) {
  int pwmFront = SERVO_CENTER + (frontDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmBack  = SERVO_CENTER + (backDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmRight = SERVO_CENTER + (rightDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmLeft  = SERVO_CENTER + (leftDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);

  pwmFront = constrain(pwmFront,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmBack  = constrain(pwmBack,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmRight = constrain(pwmRight,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmLeft  = constrain(pwmLeft,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);

  finFront.write(pwmFront);
  finRight.write(pwmRight);
  finBack.write(pwmBack);
  finLeft.write(pwmLeft);
}

// === MAP JOYSTICK READING TO ±FIN_ANGLE_MAX ===
float mapJoystickToAngle(int reading) {
  float norm = (reading - 512.0f) / 512.0f;  // -1..+1
  if (norm > 1.0f)  norm = 1.0f;
  if (norm < -1.0f) norm = -1.0f;
  return norm * FIN_ANGLE_MAX;
}
