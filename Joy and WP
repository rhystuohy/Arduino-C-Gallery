/*
  Rocket Controller with JOYSTICK Manual Mode + AUTO (Waypoint) Mode
  – Revised to ensure equal prioritization of X, Y, and Z:
    • In AUTO mode, thrust is set high enough to overcome gravity continually
      until the waypoint is reached (ignores fuel depletion).
    • Uses a PD controller that points the rocket’s body axis directly at (X,Y,Z).
    • Stops all motion and prints “Waypoint reached!” once within tolerance in 3D,
      then waits for next “MAN” or “AUTO” command.
    • Serial output every 500 ms.
    • Servos:
        Front → pin 3
        Right → pin 9
        Back  → pin 6
        Left  → pin 5
    • Joystick in MAN mode:
        Pitch → A4
        Yaw   → A5

  Author: Combined & revised 2025-06-03
*/

#include <Servo.h>
#include <Wire.h>
#include <SPI.h>
#include <math.h>

// === PIN ASSIGNMENTS ===
const int PIN_SERVO_FRONT = 3;
const int PIN_SERVO_RIGHT = 5;   // swapped
const int PIN_SERVO_BACK  = 9;
const int PIN_SERVO_LEFT  = 6;   // swapped

const int PIN_JOYSTICK_PITCH = A4;  // vertical axis
const int PIN_JOYSTICK_YAW   = A5;  // horizontal axis

// === CONSTANTS ===
const float FIN_ANGLE_MAX  = 30.0;    // degrees
const int   SERVO_CENTER   = 90;      // center PWM
const int   SERVO_RANGE    = 60;      // ±30° span

const float MASS_TOTAL     = 20.0;    // kg (payload + “sufficient fuel”)
const float THRUST_FACTOR  = 1.5;     // multiplier so thrust = 1.5 × weight

const float GRAVITY        = 9.81;    // m/s²

const float AIR_DENSITY    = 1.2;     // kg/m³
const float AREA_ROCKET    = 0.1;     // m² (approx cross-sectional)
const float CD_ROCKET      = 0.75;    // drag coefficient

const float WAYPOINT_TOL   = 2.0;     // meters tolerance for “reached”

// PD gains (tune if needed)
const float Kp_pitch = 2.0;    // deg/s² per degree error
const float Kd_pitch = 0.8;    // damping term
const float Kp_yaw   = 2.0;
const float Kd_yaw   = 0.8;

// === GLOBAL VARIABLES ===
Servo finFront, finRight, finBack, finLeft;

String mode = "MAN";      // “MAN” or “AUTO”
bool isLaunched    = false;
bool autoParamsSet = false;
int  autoInputStage= 0;   // 0=X, 1=Y, 2=Z, 3=done

unsigned long launchMillis     = 0;
unsigned long lastUpdateMillis = 0;
unsigned long lastPrintMillis  = 0;

float posX = 0, posY = 0, posZ = 0;   // inertial position (m)
float velX = 0, velY = 0, velZ = 0;   // inertial velocity (m/s)
float accX = 0, accY = 0, accZ = 0;   // inertial acceleration (m/s²)

float pitchDeg = 0, yawDeg = 0, rollDeg = 0;    // orientation (deg)
float pitchRate = 0, yawRate = 0, rollRate = 0; // angular rates (deg/s)

float waypointX = 0, waypointY = 0, waypointZ = 0;

// === FUNCTION DECLARATIONS ===
void setup();
void loop();
void handleSerial();
void enterManualMode();
void enterAutoMode();
void manualModeLoop();
void autoModeLoop();
void updateRocketPhysics(float dt);
float computeDragMagnitude(float vx, float vy, float vz);
void computeAttitudeFromIMU(float dt);  // stub or IMU fusion
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg);
float mapJoystickToAngle(int reading);

// === SETUP ===
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("=== Rocket Controller Starting ===");

  // Attach servos
  finFront.attach(PIN_SERVO_FRONT);
  finRight.attach(PIN_SERVO_RIGHT);
  finBack.attach(PIN_SERVO_BACK);
  finLeft.attach(PIN_SERVO_LEFT);

  // Center fins
  setAllFins(0, 0, 0, 0);

  lastUpdateMillis = millis();
  lastPrintMillis  = millis();
}

// === MAIN LOOP ===
void loop() {
  handleSerial();

  if (mode == "MAN") {
    manualModeLoop();
  }
  else if (mode == "AUTO") {
    autoModeLoop();
  }
  else {
    // Idle until “MAN” or “AUTO” entered
  }
}

// === SERIAL HANDLING ===
void handleSerial() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    input.trim();

    if (input.equalsIgnoreCase("MAN")) {
      if (mode != "MAN") {
        mode = "MAN";
        enterManualMode();
      }
    }
    else if (input.equalsIgnoreCase("AUTO")) {
      if (mode != "AUTO") {
        mode = "AUTO";
        enterAutoMode();
      }
    }
    else if (mode == "AUTO" && !autoParamsSet) {
      // Collect waypoint X, then Y, then Z
      float val = input.toFloat();
      bool valid = false;
      if (autoInputStage == 0) {
        waypointX = val;
        valid = true;
      }
      else if (autoInputStage == 1) {
        waypointY = val;
        valid = true;
      }
      else if (autoInputStage == 2) {
        waypointZ = val;
        valid = true;
      }
      if (valid) {
        autoInputStage++;
        if (autoInputStage == 1) {
          Serial.print("Waypoint X = "); Serial.println(waypointX,2);
          Serial.println("Enter waypoint Y:");
          Serial.print("> ");
        }
        else if (autoInputStage == 2) {
          Serial.print("Waypoint Y = "); Serial.println(waypointY,2);
          Serial.println("Enter waypoint Z:");
          Serial.print("> ");
        }
        else if (autoInputStage == 3) {
          Serial.print("Waypoint Z = "); Serial.println(waypointZ,2);
          autoParamsSet = true;
          Serial.println("Waypoint set. Starting AUTO...");
          // Initialize launch state
          if (!isLaunched) {
            isLaunched = true;
            launchMillis = millis();
            lastUpdateMillis = millis();
            posX = posY = posZ = 0;
            velX = velY = velZ = 0;
            pitchDeg = yawDeg = rollDeg = 0;
            pitchRate = yawRate = rollRate = 0;
          }
        }
      }
      else {
        Serial.println("Invalid number. Please re-enter:");
        if (autoInputStage == 0) Serial.println("Enter waypoint X:");
        else if (autoInputStage == 1) Serial.println("Enter waypoint Y:");
        else if (autoInputStage == 2) Serial.println("Enter waypoint Z:");
        Serial.print("> ");
      }
    }
  }
}

// === MODE SWITCH ===
void enterManualMode() {
  Serial.println("MODE: MANUAL");
  mode = "MAN";
  autoParamsSet = false;
  autoInputStage = 0;
  isLaunched = false;
  Serial.println("Use joystick (A4 pitch, A5 yaw) to move fins.");
}

void enterAutoMode() {
  Serial.println("MODE: AUTO");
  mode = "AUTO";
  autoParamsSet = false;
  autoInputStage = 0;
  isLaunched = false;
  Serial.println("Enter waypoint X:");
  Serial.print("> ");
}

// === MANUAL MODE ===
void manualModeLoop() {
  // Read joystick 0..1023
  int rawPitch = analogRead(PIN_JOYSTICK_PITCH);
  int rawYaw   = analogRead(PIN_JOYSTICK_YAW);

  // Map to ±FIN_ANGLE_MAX
  float pitchDef = mapJoystickToAngle(rawPitch);
  float yawDef   = mapJoystickToAngle(rawYaw);

  // Assign fins: front/back for pitch, right/left for yaw
  float finFrontDeg = pitchDef;  
  float finBackDeg  = -pitchDef;
  float finRightDeg = yawDef;
  float finLeftDeg  = -yawDef;

  setAllFins(finFrontDeg, finRightDeg, finBackDeg, finLeftDeg);

  // Update simulated attitude (or real IMU) 
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3;
  lastUpdateMillis = now;
  computeAttitudeFromIMU(dt);

  // Print every 500 ms
  if (now - lastPrintMillis >= 500) {
    lastPrintMillis = now;
    Serial.print("MANUAL | ATT°: P=");
    Serial.print(pitchDeg,1);
    Serial.print(" Y=");
    Serial.print(yawDeg,1);
    Serial.print(" R=");
    Serial.println(rollDeg,1);
  }
  delay(10);
}

// === AUTO MODE ===
void autoModeLoop() {
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3;
  lastUpdateMillis = now;

  if (!autoParamsSet) {
    // Still waiting for X, Y, Z
    return;
  }

  // 1) Compute 3D error
  float dX = waypointX - posX;
  float dY = waypointY - posY;
  float dZ = waypointZ - posZ;
  float dist3D = sqrt(dX*dX + dY*dY + dZ*dZ);

  // 2) Check if within tolerance
  if (dist3D <= WAYPOINT_TOL) {
    setAllFins(0, 0, 0, 0);
    Serial.println("Waypoint reached!");
    mode = ""; 
    isLaunched = false;
    autoParamsSet = false;
    Serial.println("Enter 'MAN' or 'AUTO' to continue.");
    return;
  }

  // 3) Desired direction: point body axis at waypoint
  float distXY = sqrt(dX*dX + dY*dY) + 1e-6;
  float desiredPitch = atan2(dZ, distXY) * 180.0 / PI;
  float desiredYaw   = atan2(dY, dX)   * 180.0 / PI;

  float errPitch = desiredPitch - pitchDeg;
  float errYaw   = desiredYaw   - yawDeg;
  if (errYaw > 180)  errYaw -= 360;
  if (errYaw < -180) errYaw += 360;

  // 4) PD for pitch
  float pitchErrorDerivative = -pitchRate;
  float pitchAcc = Kp_pitch * errPitch + Kd_pitch * pitchErrorDerivative;
  pitchRate += pitchAcc * dt;
  pitchDeg += pitchRate * dt;

  // 5) PD for yaw
  float yawErrorDerivative = -yawRate;
  float yawAcc = Kp_yaw * errYaw + Kd_yaw * yawErrorDerivative;
  yawRate += yawAcc * dt;
  yawDeg += yawRate * dt;

  // 6) Residual error
  float errPitch2 = desiredPitch - pitchDeg;
  float errYaw2   = desiredYaw - yawDeg;
  if (errYaw2 > 180)  errYaw2 -= 360;
  if (errYaw2 < -180) errYaw2 += 360;

  // 7) Fin commands
  float finPitchCmd = constrain(errPitch2 * 0.5, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);
  float finYawCmd   = constrain(errYaw2   * 0.5, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);

  float frontCmd = finPitchCmd;
  float backCmd  = -finPitchCmd;
  float rightCmd = finYawCmd;
  float leftCmd  = -finYawCmd;

  // 8) Smooth deflections
  static float filtFront=0, filtBack=0, filtRight=0, filtLeft=0;
  const float alpha = 0.02;
  filtFront = filtFront + alpha * (frontCmd - filtFront);
  filtBack  = filtBack  + alpha * (backCmd  - filtBack);
  filtRight = filtRight + alpha * (rightCmd - filtRight);
  filtLeft  = filtLeft  + alpha * (leftCmd  - filtLeft);

  setAllFins(filtFront, filtRight, filtBack, filtLeft);

  // 9) Update physics with strong constant thrust
  updateRocketPhysics(dt);

  // 10) Print every 500 ms
  if (now - lastPrintMillis >= 500) {
    lastPrintMillis = now;
    Serial.print("AUTO | POS(m)=(");
    Serial.print(posX,1); Serial.print(",");
    Serial.print(posY,1); Serial.print(",");
    Serial.print(posZ,1); Serial.print(") ");
    Serial.print("DistToWP="); Serial.print(dist3D,1); Serial.print("m ");
    Serial.print("| Fins=(P:"); Serial.print(filtFront,1);
    Serial.print(",Y:"); Serial.print(filtRight,1);
    Serial.print(","); Serial.print(filtBack,1);
    Serial.print(","); Serial.print(filtLeft,1);
    Serial.println(")");
  }

  delay(10);
}

// === UPDATE ROCKET PHYSICS ===
void updateRocketPhysics(float dt) {
  if (!isLaunched) {
    // First time in AUTO (after waypoint set)
    isLaunched = true;
    launchMillis = millis();
    posX = posY = posZ = 0;
    velX = velY = velZ = 0;
  }

  // 1) Compute constant thrust = THRUST_FACTOR × weight
  float thrust = MASS_TOTAL * GRAVITY * THRUST_FACTOR;

  // 2) Decompose into inertial axes
  float pitchRad = pitchDeg * PI / 180.0;
  float yawRad   = yawDeg   * PI / 180.0;
  float t_x = thrust * sin(pitchRad) * cos(yawRad);
  float t_y = thrust * sin(pitchRad) * sin(yawRad);
  float t_z = thrust * cos(pitchRad);

  // 3) Compute drag magnitude
  float dragMag = computeDragMagnitude(velX, velY, velZ);
  float speed   = sqrt(velX*velX + velY*velY + velZ*velZ) + 1e-6;
  float dragX = dragMag * (velX / speed);
  float dragY = dragMag * (velY / speed);
  float dragZ = dragMag * (velZ / speed);

  // 4) Net forces
  float FnetX = t_x - dragX;
  float FnetY = t_y - dragY;
  float FnetZ = t_z - (MASS_TOTAL * GRAVITY) - dragZ;

  // 5) Accelerations
  accX = FnetX / MASS_TOTAL;
  accY = FnetY / MASS_TOTAL;
  accZ = FnetZ / MASS_TOTAL;

  // 6) Update velocities
  velX += accX * dt;
  velY += accY * dt;
  velZ += accZ * dt;

  // 7) Update positions
  posX += velX * dt;
  posY += velY * dt;
  posZ += velZ * dt;
}

// === COMPUTE DRAG MAGNITUDE ===
float computeDragMagnitude(float vx, float vy, float vz) {
  float speed = sqrt(vx*vx + vy*vy + vz*vz);
  return 0.5 * AIR_DENSITY * speed * speed * AREA_ROCKET * CD_ROCKET;
}

// === STUB: ATTITUDE FROM IMU ===
void computeAttitudeFromIMU(float dt) {
  // If you have a real IMU/MPU6050, insert fusion code here to update:
  //   pitchDeg, yawDeg, rollDeg, pitchRate, yawRate, rollRate.
  // Otherwise, attitude is updated in autoModeLoop().
}

// === SET ALL FINS ===
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg) {
  int pwmFront = SERVO_CENTER + (frontDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmBack  = SERVO_CENTER + (backDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmRight = SERVO_CENTER + (rightDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmLeft  = SERVO_CENTER + (leftDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);

  pwmFront = constrain(pwmFront,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmBack  = constrain(pwmBack,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmRight = constrain(pwmRight,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmLeft  = constrain(pwmLeft,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);

  finFront.write(pwmFront);
  finRight.write(pwmRight);
  finBack.write(pwmBack);
  finLeft.write(pwmLeft);
}

// === MAP JOYSTICK READING TO ±FIN_ANGLE_MAX ===
float mapJoystickToAngle(int reading) {
  float norm = (reading - 512.0) / 512.0;  // -1..+1
  if (norm > 1.0) norm = 1.0;
  if (norm < -1.0) norm = -1.0;
  return norm * FIN_ANGLE_MAX;
}
