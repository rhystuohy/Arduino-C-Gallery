#include <Servo.h>
#include <math.h>

// ‚Äî‚Äî‚Äî Pin assignments ‚Äî‚Äî‚Äî
constexpr int PIN_SERVO_PF    = 3;
constexpr int PIN_SERVO_PB    = 5;
constexpr int PIN_SERVO_YL    = 6;
constexpr int PIN_SERVO_YR    = 9;
constexpr int PIN_JOYSTICK_X  = A4;
constexpr int PIN_JOYSTICK_Y  = A5;

// ‚Äî‚Äî‚Äî Servos ‚Äî‚Äî‚Äî
Servo servoPF, servoPB, servoYL, servoYR;

// ‚Äî‚Äî‚Äî State & target ‚Äî‚Äî‚Äî
float posX = 0.0f, posY = 0.0f, posZ = 0.0f;   // position (m)
float tx   = 0.0f, ty   = 0.0f, tz   = 0.0f;   // waypoint (m)
bool  manualMode   = true;    // start in manual
bool  aborted      = false;
bool  waypointSet  = false;   // true after SET

// ‚Äî‚Äî‚Äî Timing & control ‚Äî‚Äî‚Äî
constexpr float LOOP_DT       = 0.05f;  // 50 ms
constexpr float REPORT_SEC    = 1.0f;   // 1 s
constexpr int   LOOPS_PER_SEC = int(REPORT_SEC / LOOP_DT + 0.5f);
int loopCounter = 0;

// PID gains for pitch:
constexpr float KP_PITCH = 0.7f;
constexpr float KI_PITCH = 0.1f;
constexpr float KD_PITCH = 0.05f;

// PID gains for yaw:
constexpr float KP_YAW   = 0.7f;
constexpr float KI_YAW   = 0.1f;
constexpr float KD_YAW   = 0.05f;

// Dynamics constants:
constexpr float K_TORQUE = 1.0f;
constexpr float I_MOMENT = 1.0f;

// Simulator constants:
constexpr float SPEED       = 20.0f;  // m/s
constexpr float MAX_DEFLECT = 20.0f;  // degrees

// PID state
float pitchErrorPrev = 0.0f;
float pitchErrorI    = 0.0f;
float yawErrorPrev   = 0.0f;
float yawErrorI      = 0.0f;

// Orientation state (rad) and angular velocity (rad/s)
float pitchAngle = 0.0f, pitchRate = 0.0f;
float yawAngle   = 0.0f, yawRate   = 0.0f;

// Current commanded fin deflections (deg)
float defPitch = 0.0f, defYaw = 0.0f;

// Closest approach tracking
float globalMinDist = 1e9;

void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println(F("=== Rocket Nav Simulator (PID + Dynamics) ==="));
  Serial.println(F("Commands (type + NL):"));
  Serial.println(F("  MODE AUTO       ‚Üí autonomous PID"));
  Serial.println(F("  MODE MAN        ‚Üí manual joystick"));
  Serial.println(F("  SET <x> <y> <z> ‚Üí set waypoint (meters)"));
  Serial.println(F("  ABORT           ‚Üí pause simulation"));
  Serial.println(F("-----------------------------------------"));
  Serial.println(F("Manual: joystick on A4 = X (yaw), A5 = Y (pitch)"));

  // Attach servos
  servoPF.attach(PIN_SERVO_PF);
  servoPB.attach(PIN_SERVO_PB);
  servoYL.attach(PIN_SERVO_YL);
  servoYR.attach(PIN_SERVO_YR);
  centerFins();

  // Initialize states
  posX = posY = posZ = 0.0f;
  pitchAngle = yawAngle = 0.0f;
  pitchRate = yawRate = 0.0f;
  defPitch = defYaw = 0.0f;
  globalMinDist = 1e9;
}

void loop() {
  handleSerial();
  if (aborted) return;

  if (manualMode) {
    manualStep();
  } else {
    autonomousPIDStep();
  }

  simulateDynamics();
  updateClosest();

  // Report position and debug every second
  if (++loopCounter >= LOOPS_PER_SEC) {
    loopCounter = 0;
    reportPosition();
  }

  delay(int(LOOP_DT * 1000));
}

// ‚Äî‚Äî‚Äî Helpers ‚Äî‚Äî‚Äî

void centerFins() {
  servoPF.write(90);
  servoPB.write(90);
  servoYL.write(90);
  servoYR.write(90);
  defPitch = defYaw = 0.0f;
  Serial.println(F("‚Üí Fins centered (90¬∞ each)"));
}

void handleSerial() {
  if (!Serial.available()) return;
  String cmd = Serial.readStringUntil('\n');
  cmd.trim();  // strip leading/trailing whitespace

  // 1) Switch to Autonomous PID mode:
  if (cmd.equalsIgnoreCase("MODE AUTO")) {
    manualMode = false;
    aborted    = false;

    // Reset all kinematic & PID state:
    posX = posY = posZ = 0.0f;
    pitchAngle = yawAngle = 0.0f;
    pitchRate  = yawRate  = 0.0f;
    defPitch   = defYaw   = 0.0f;
    globalMinDist   = 1e9;
    waypointSet     = false;
    pitchErrorPrev  = pitchErrorI = 0.0f;
    yawErrorPrev    = yawErrorI   = 0.0f;

    Serial.println(F("‚Üí Switched to AUTONOMOUS PID; position/orientation reset to 0"));
    Serial.println(F("   (Now type: SET <x> <y> <z> to define waypoint in meters)"));
    centerFins();
  }

  // 2) Switch to Manual joystick mode:
  else if (cmd.equalsIgnoreCase("MODE MAN")) {
    manualMode = true;
    aborted    = false;

    // Reset all kinematic & PID state:
    posX = posY = posZ = 0.0f;
    pitchAngle = yawAngle = 0.0f;
    pitchRate  = yawRate  = 0.0f;
    defPitch   = defYaw   = 0.0f;
    globalMinDist   = 1e9;
    pitchErrorPrev  = pitchErrorI = 0.0f;
    yawErrorPrev    = yawErrorI   = 0.0f;

    Serial.println(F("‚Üí Switched to MANUAL joystick; position/orientation reset to 0"));
    centerFins();
  }

  // 3) SET command (expects exactly ‚ÄúSET <float> <float> <float>‚Äù):
  else if (cmd.startsWith("SET ")) {
    float x, y, z;
    // Try to parse three floats from the entire command string:
    if (sscanf(cmd.c_str(), "SET %f %f %f", &x, &y, &z) == 3) {
      tx = x; ty = y; tz = z;
      waypointSet = true;
      globalMinDist = 1e9;

      // Reset PID integrators:
      pitchErrorI = pitchErrorPrev = 0.0f;
      yawErrorI   = yawErrorPrev   = 0.0f;

      Serial.print(F("‚Üí Waypoint set to ("));
      Serial.print(tx,2); Serial.print(F(", "));
      Serial.print(ty,2); Serial.print(F(", "));
      Serial.print(tz,2); Serial.println(F(") meters"));
    } else {
      Serial.println(F("! Invalid SET syntax (use: SET x y z)"));
    }
  }

  // 4) Abort:
  else if (cmd.equalsIgnoreCase("ABORT")) {
    aborted = true;
    Serial.println(F("‚Üí ABORTED: simulation paused. Type MODE AUTO or MODE MAN to restart."));
    centerFins();
  }
}
void manualStep() {
  // Read joystick (0‚Äì1023)
  int rawX = analogRead(PIN_JOYSTICK_X);
  int rawY = analogRead(PIN_JOYSTICK_Y);
  const float CENTER = 512.0f;
  float normX = (rawX - CENTER) / CENTER;  // -1..+1 for yaw
  float normY = (CENTER - rawY) / CENTER;  // -1..+1 for pitch (inverted)
  defYaw   = constrain(normX * MAX_DEFLECT, -MAX_DEFLECT, +MAX_DEFLECT);
  defPitch = constrain(normY * MAX_DEFLECT, -MAX_DEFLECT, +MAX_DEFLECT);
  applyFins(defPitch, defYaw);
}

void autonomousPIDStep() {
  if (!waypointSet) {
    centerFins();
    return;
  }

  // Compute error components
  float ex = tx - posX;
  float ey = ty - posY;
  float ez = tz - posZ;
  float dist = sqrt(ex*ex + ey*ey + ez*ez);

  if (dist < 0.5f) {
    // Close enough: center fins and stop
    centerFins();
    return;
  }

  // Desired angles (deg):
  //  - pitch: positive means target is ahead in X direction relative to Z
  //  - yaw:   positive means target is to the right in Y direction relative to Z
  float desiredPitch = atan2(ex, ez) * 180.0f / PI;
  float desiredYaw   = atan2(ey, ez) * 180.0f / PI;

  // PID for pitch
  float currentPitchDeg = pitchAngle * 180.0f / PI;
  float errorPitch = desiredPitch - currentPitchDeg;
  pitchErrorI += errorPitch * LOOP_DT;
  float dErrorPitch = (errorPitch - pitchErrorPrev) / LOOP_DT;
  float outPitch = KP_PITCH * errorPitch + KI_PITCH * pitchErrorI + KD_PITCH * dErrorPitch;
  pitchErrorPrev = errorPitch;

  // PID for yaw
  float currentYawDeg = yawAngle * 180.0f / PI;
  float errorYaw = desiredYaw - currentYawDeg;
  yawErrorI += errorYaw * LOOP_DT;
  float dErrorYaw = (errorYaw - yawErrorPrev) / LOOP_DT;
  float outYaw = KP_YAW * errorYaw + KI_YAW * yawErrorI + KD_YAW * dErrorYaw;
  yawErrorPrev = errorYaw;

  // Constrain to max deflection
  defPitch = constrain(outPitch, -MAX_DEFLECT, +MAX_DEFLECT);
  defYaw   = constrain(outYaw,   -MAX_DEFLECT, +MAX_DEFLECT);

  // Print debug once every second
  if (loopCounter == 0) {
    Serial.print(F("‚Üí PID errs: P="));
    Serial.print(errorPitch,2);
    Serial.print(F("¬∞, Y="));
    Serial.print(errorYaw,2);
    Serial.print(F("¬∞ | defl: P="));
    Serial.print(defPitch,2);
    Serial.print(F("¬∞, Y="));
    Serial.print(defYaw,2);
    Serial.println(F("¬∞"));
  }

  applyFins(defPitch, defYaw);
}

void applyFins(float dp, float dy) {
  int pf = constrain(90 - dp, 0, 180);
  int pb = constrain(90 + dp, 0, 180);
  int yl = constrain(90 - dy, 0, 180);
  int yr = constrain(90 + dy, 0, 180);
  servoPF.write(pf);
  servoPB.write(pb);
  servoYL.write(yl);
  servoYR.write(yr);

  // Print servo angles once every second
  if (loopCounter == 0) {
    Serial.print(F("‚Üí Servo angles PF,PB,YL,YR = "));
    Serial.print(pf); Serial.print(F(", "));
    Serial.print(pb); Serial.print(F(", "));
    Serial.print(yl); Serial.print(F(", "));
    Serial.println(yr);
  }
}

void simulateDynamics() {
  // Convert commanded deflections to radians for torque calc
  float defPitchRad = defPitch * PI / 180.0f;
  float defYawRad   = defYaw   * PI / 180.0f;

  // Angular accelerations (Œ± = torque / I; torque ~ K_TORQUE * deflectionRad)
  float pitchAcc = (K_TORQUE * defPitchRad) / I_MOMENT;
  float yawAcc   = (K_TORQUE * defYawRad)   / I_MOMENT;

  // Integrate angular rates and angles
  pitchRate += pitchAcc * LOOP_DT;
  yawRate   += yawAcc   * LOOP_DT;
  pitchAngle += pitchRate * LOOP_DT;
  yawAngle   += yawRate   * LOOP_DT;

  // Compute unit direction vector from orientation
  float ux = sin(pitchAngle);                    // tilt from +Z into +X
  float uy = sin(yawAngle);                      // tilt from +Z into +Y
  float uz = cos(pitchAngle) * cos(yawAngle);    // forward component

  // Update position along that direction
  posX += ux * SPEED * LOOP_DT;
  posY += uy * SPEED * LOOP_DT;
  posZ += uz * SPEED * LOOP_DT;
}

void updateClosest() {
  if (!waypointSet) return;
  float dx = tx - posX;
  float dy = ty - posY;
  float dz = tz - posZ;
  float d  = sqrt(dx*dx + dy*dy + dz*dz);
  if (d < globalMinDist) {
    globalMinDist = d;
    Serial.print(F("üèÅ New closest: "));
    Serial.print(d,2);
    Serial.print(F(" m at POS("));
    Serial.print(posX,2); Serial.print(F(", "));
    Serial.print(posY,2); Serial.print(F(", "));
    Serial.print(posZ,2); Serial.println(F(")"));
  }
}

void reportPosition() {
  Serial.print(F("POS("));
  Serial.print(posX,2); Serial.print(F(", "));
  Serial.print(posY,2); Serial.print(F(", "));
  Serial.print(posZ,2); Serial.println(F(") m"));
}
