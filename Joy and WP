/*
  Rocket Controller with JOYSTICK Manual Mode + AUTO (Waypoint) Mode
  – Manual mode now uses joystick‐set pitch/yaw to move rocket in 3D exactly like AUTO.
  – AUTO mode remains unchanged (2 m/s² along body axis, PD‐controlled fins toward waypoint).
  – Telemetry every 250 ms.
  – Manual: “ABORT” stops motion and returns to idle.
  – Servos:
      Front → pin 3
      Right → pin 9
      Back  → pin 6
      Left  → pin 5
  – Joystick:
      Pitch → A4 (sets pitchDeg directly)
      Yaw   → A5 (sets yawDeg directly)

  Author: Combined & revised June 3, 2025
*/

#include <Servo.h>
#include <Wire.h>
#include <SPI.h>
#include <math.h>

// === PIN ASSIGNMENTS ===
const int PIN_SERVO_FRONT = 3;
const int PIN_SERVO_RIGHT = 9;
const int PIN_SERVO_BACK  = 6;
const int PIN_SERVO_LEFT  = 5;

const int PIN_JOYSTICK_PITCH = A4;  // vertical axis
const int PIN_JOYSTICK_YAW   = A5;  // horizontal axis

// === CONSTANTS ===
const float FIN_ANGLE_MAX   = 30.0f;   // degrees
const int   SERVO_CENTER    = 90;      // center PWM
const int   SERVO_RANGE     = 60;      // ±30° span

const float ACC_MAGNITUDE   = 2.0f;    // m/s² along body‐axis
const float WAYPOINT_TOL    = 2.0f;    // meters tolerance

// PD gains (for AUTO only)
const float Kp_pitch = 2.0f;    // deg/s² per deg error
const float Kd_pitch = 0.8f;    // damping
const float Kp_yaw   = 2.0f;
const float Kd_yaw   = 0.8f;

// === GLOBAL VARIABLES ===
Servo finFront, finRight, finBack, finLeft;

String mode = "";            // "", "MAN", or "AUTO"
bool isLaunched     = false;
bool autoParamsSet  = false;
int  autoInputStage = 0;     // 0=X, 1=Y, 2=Z, 3=ready

unsigned long launchMillis     = 0;
unsigned long lastUpdateMillis = 0;
unsigned long lastPrintMillis  = 0;

float posX = 0, posY = 0, posZ = 0;   // m
float velX = 0, velY = 0, velZ = 0;   // m/s
float accX = 0, accY = 0, accZ = 0;   // m/s²

float pitchDeg = 0, yawDeg = 0, rollDeg = 0;    // deg
float pitchRate = 0, yawRate = 0, rollRate = 0; // deg/s

float waypointX = 0, waypointY = 0, waypointZ = 0;
float prevDist3D = 1e6f;   // track closest

// === FUNCTION DECLARATIONS ===
void setup();
void loop();
void handleSerial();
void enterManualMode();
void enterAutoMode();
void manualModeLoop();
void autoModeLoop();
void updateRocketPhysics(float dt);
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg);
float mapJoystickToAngle(int reading);

// === SETUP ===
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("=== Rocket Controller Starting ===");

  finFront.attach(PIN_SERVO_FRONT);
  finRight.attach(PIN_SERVO_RIGHT);
  finBack.attach(PIN_SERVO_BACK);
  finLeft.attach(PIN_SERVO_LEFT);

  setAllFins(0, 0, 0, 0);

  lastUpdateMillis = millis();
  lastPrintMillis  = millis();
}

// === MAIN LOOP ===
void loop() {
  handleSerial();

  if (mode == "MAN") {
    manualModeLoop();
  }
  else if (mode == "AUTO") {
    autoModeLoop();
  }
  else {
    // Idle until “MAN” or “AUTO”
  }
}

// === SERIAL HANDLING ===
void handleSerial() {
  if (!Serial.available()) return;

  String input = Serial.readStringUntil('\n');
  input.trim();

  if (mode == "MAN" && input.equalsIgnoreCase("ABORT")) {
    setAllFins(0, 0, 0, 0);
    Serial.println("Manual ABORT. Waiting for 'MAN' or 'AUTO'.");
    mode = "";
    isLaunched = false;
    return;
  }

  if (input.equalsIgnoreCase("MAN")) {
    mode = "MAN";
    enterManualMode();
    return;
  }

  if (input.equalsIgnoreCase("AUTO")) {
    mode = "AUTO";
    enterAutoMode();
    return;
  }

  if (mode == "AUTO" && !autoParamsSet) {
    float val = input.toFloat();
    bool valid = false;
    if (autoInputStage == 0) {
      waypointX = val; valid = true;
    }
    else if (autoInputStage == 1) {
      waypointY = val; valid = true;
    }
    else if (autoInputStage == 2) {
      waypointZ = val; valid = true;
    }
    if (valid) {
      autoInputStage++;
      if (autoInputStage == 1) {
        Serial.print("Waypoint X = "); Serial.println(waypointX,2);
        Serial.println("Enter waypoint Y:");
        Serial.print("> ");
      }
      else if (autoInputStage == 2) {
        Serial.print("Waypoint Y = "); Serial.println(waypointY,2);
        Serial.println("Enter waypoint Z:");
        Serial.print("> ");
      }
      else if (autoInputStage == 3) {
        Serial.print("Waypoint Z = "); Serial.println(waypointZ,2);
        autoParamsSet = true;
        Serial.println("Waypoint set. Starting AUTO...");
        isLaunched = false;
        prevDist3D = 1e6f;
        posX = posY = posZ = 0;
        velX = velY = velZ = 0;
        pitchDeg = yawDeg = rollDeg = 0;
        pitchRate = yawRate = rollRate = 0;
      }
    }
    else {
      Serial.println("Invalid number. Please re-enter:");
      if (autoInputStage == 0)   Serial.println("Enter waypoint X:");
      else if (autoInputStage == 1) Serial.println("Enter waypoint Y:");
      else if (autoInputStage == 2) Serial.println("Enter waypoint Z:");
      Serial.print("> ");
    }
  }
}

// === MODE SWITCH ROUTINES ===
void enterManualMode() {
  Serial.println("===== MANUAL MODE =====");
  Serial.println("Type 'ABORT' to exit manual mode.");
  mode = "MAN";
  autoParamsSet = false;
  autoInputStage = 0;
  isLaunched = false;
}

void enterAutoMode() {
  Serial.println("===== AUTO MODE =====");
  mode = "AUTO";
  autoParamsSet = false;
  autoInputStage = 0;
  Serial.println("Enter waypoint X:");
  Serial.print("> ");
}

// === MANUAL MODE ===
void manualModeLoop() {
  // 1) Read joystick (0–1023)
  int rawPitch = analogRead(PIN_JOYSTICK_PITCH);
  int rawYaw   = analogRead(PIN_JOYSTICK_YAW);

  // 2) Map to ±FIN_ANGLE_MAX
  float pitchDef = mapJoystickToAngle(rawPitch);
  float yawDef   = mapJoystickToAngle(rawYaw);

  // 3) Set orientation directly
  pitchDeg = pitchDef;
  yawDeg   = yawDef;
  rollDeg  = 0; // always zero in this model

  // 4) Send fins to match stick (purely cosmetic, since orientation is direct)
  setAllFins(pitchDef, yawDef, -pitchDef, -yawDef);

  // 5) Update physics: accelerate 2 m/s² along body axis
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3f;
  lastUpdateMillis = now;
  updateRocketPhysics(dt);

  // 6) Print telemetry every 250 ms
  if (now - lastPrintMillis >= 250) {
    lastPrintMillis = now;
    Serial.print("MANUAL | POS(m)=(");
    Serial.print(posX,2); Serial.print(",");
    Serial.print(posY,2); Serial.print(",");
    Serial.print(posZ,2); Serial.print(") ");
    Serial.print("ATT°=P:");
    Serial.print(pitchDeg,1); Serial.print(" Y:");
    Serial.print(yawDeg,1); Serial.print(" R:");
    Serial.println(rollDeg,1);
  }

  delay(10);
}

// === AUTO MODE ===
void autoModeLoop() {
  unsigned long now = millis();
  float dt = (now - lastUpdateMillis) * 1e-3f;
  lastUpdateMillis = now;

  if (!autoParamsSet) return;

  if (!isLaunched) {
    isLaunched = true;
    launchMillis = millis();
    posX = posY = posZ = 0;
    velX = velY = velZ = 0;
    pitchDeg = yawDeg = rollDeg = 0;
    pitchRate = yawRate = rollRate = 0;
    prevDist3D = 1e6f;
  }

  // 1) 3D error
  float dX = waypointX - posX;
  float dY = waypointY - posY;
  float dZ = waypointZ - posZ;
  float dist3D = sqrt(dX*dX + dY*dY + dZ*dZ);

  // 2) Track closest
  static bool passedClosest = false;
  if (dist3D < prevDist3D) {
    prevDist3D = dist3D;
    passedClosest = false;
  } else if (!passedClosest && dist3D > prevDist3D) {
    passedClosest = true;
  }

  // 3) Stop if within tol or passed closest
  if (dist3D <= WAYPOINT_TOL || passedClosest) {
    setAllFins(0, 0, 0, 0);
    Serial.print("Waypoint reached! Closest dist = ");
    Serial.print(prevDist3D,2);
    Serial.print(" m at POS=(");
    Serial.print(posX,2); Serial.print(",");
    Serial.print(posY,2); Serial.print(",");
    Serial.print(posZ,2); Serial.println(")");
    mode = "";
    isLaunched = false;
    autoParamsSet = false;
    Serial.println("Enter 'MAN' or 'AUTO' to continue.");
    return;
  }

  // 4) Desired orientation
  float distXY = sqrt(dX*dX + dY*dY) + 1e-6f;
  float desiredPitch = atan2(dZ, distXY) * 180.0f / PI;
  float desiredYaw   = atan2(dY, dX)   * 180.0f / PI;

  float errPitch = desiredPitch - pitchDeg;
  float errYaw   = desiredYaw   - yawDeg;
  if (errYaw > 180.0f)  errYaw -= 360.0f;
  if (errYaw < -180.0f) errYaw += 360.0f;

  // 5) PD for pitch
  float pitchErrorDerivative = -pitchRate;
  float pitchAcc = Kp_pitch * errPitch + Kd_pitch * pitchErrorDerivative;
  pitchRate += pitchAcc * dt;
  pitchDeg  += pitchRate * dt;

  // 6) PD for yaw
  float yawErrorDerivative = -yawRate;
  float yawAcc = Kp_yaw * errYaw + Kd_yaw * yawErrorDerivative;
  yawRate += yawAcc * dt;
  yawDeg  += yawRate * dt;

  // 7) Residual errors
  float errPitch2 = desiredPitch - pitchDeg;
  float errYaw2   = desiredYaw   - yawDeg;
  if (errYaw2 > 180.0f)  errYaw2 -= 360.0f;
  if (errYaw2 < -180.0f) errYaw2 += 360.0f;

  // 8) Fin commands
  float finPitchCmd = constrain(errPitch2 * 0.5f, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);
  float finYawCmd   = constrain(errYaw2   * 0.5f, -FIN_ANGLE_MAX, FIN_ANGLE_MAX);

  float frontCmd = finPitchCmd;
  float backCmd  = -finPitchCmd;
  float rightCmd = finYawCmd;
  float leftCmd  = -finYawCmd;

  // 9) Smooth deflections
  static float filtFront=0, filtBack=0, filtRight=0, filtLeft=0;
  const float alpha = 0.02f;
  filtFront = filtFront + alpha * (frontCmd - filtFront);
  filtBack  = filtBack  + alpha * (backCmd  - filtBack);
  filtRight = filtRight + alpha * (rightCmd - filtRight);
  filtLeft  = filtLeft  + alpha * (leftCmd  - filtLeft);

  setAllFins(filtFront, filtRight, filtBack, filtLeft);

  // 10) Update physics
  updateRocketPhysics(dt);

  // 11) Print every 250 ms
  if (now - lastPrintMillis >= 250) {
    lastPrintMillis = now;
    Serial.print("AUTO | POS(m)=(");
    Serial.print(posX,2); Serial.print(",");
    Serial.print(posY,2); Serial.print(",");
    Serial.print(posZ,2); Serial.print(") ");
    Serial.print("Dist="); Serial.print(dist3D,2); Serial.print("m ");
    Serial.print("| Fins=(P:");
    Serial.print(filtFront,1); Serial.print(",Y:");
    Serial.print(filtRight,1); Serial.print(",");
    Serial.print(filtBack,1); Serial.print(",");
    Serial.print(filtLeft,1); Serial.println(")");
  }

  delay(10);
}

// === UPDATE ROCKET PHYSICS ===
void updateRocketPhysics(float dt) {
  float pitchRad = pitchDeg * PI / 180.0f;
  float yawRad   = yawDeg   * PI / 180.0f;

  // Body‐axis unit vector (in inertial frame)
  float ux = sin(pitchRad) * cos(yawRad);
  float uy = sin(pitchRad) * sin(yawRad);
  float uz = cos(pitchRad);

  // Always accelerate 2 m/s² along body axis
  accX = ACC_MAGNITUDE * ux;
  accY = ACC_MAGNITUDE * uy;
  accZ = ACC_MAGNITUDE * uz;

  // Integrate velocity
  velX += accX * dt;
  velY += accY * dt;
  velZ += accZ * dt;

  // Integrate position
  posX += velX * dt;
  posY += velY * dt;
  posZ += velZ * dt;
}

// === SET ALL FINS ===
void setAllFins(float frontDeg, float rightDeg, float backDeg, float leftDeg) {
  int pwmFront = SERVO_CENTER + (frontDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmBack  = SERVO_CENTER + (backDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmRight = SERVO_CENTER + (rightDeg / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);
  int pwmLeft  = SERVO_CENTER + (leftDeg  / FIN_ANGLE_MAX) * (SERVO_RANGE / 2);

  pwmFront = constrain(pwmFront,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmBack  = constrain(pwmBack,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmRight = constrain(pwmRight,  SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);
  pwmLeft  = constrain(pwmLeft,   SERVO_CENTER - SERVO_RANGE/2, SERVO_CENTER + SERVO_RANGE/2);

  finFront.write(pwmFront);
  finRight.write(pwmRight);
  finBack.write(pwmBack);
  finLeft.write(pwmLeft);
}

// === MAP JOYSTICK TO ±FIN_ANGLE_MAX ===
float mapJoystickToAngle(int reading) {
  float norm = (reading - 512.0f) / 512.0f;  // -1..+1
  if (norm > 1.0f)  norm = 1.0f;
  if (norm < -1.0f) norm = -1.0f;
  return norm * FIN_ANGLE_MAX;
}
